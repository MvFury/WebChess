<!DOCTYPE html>
<html>

<style>

.coordinate-wrapper {
  border-collapse: collapse;
}
.file-coord {
  width: 50px;
  height: 20px;
  text-align: center;
  font-weight: bold;
  font-size: 16px !important;
  border: none;
  background-color: #f0f0f0;
}

.rank-coord {
  width: 20px;
  height: 50px;
  text-align: center;
  font-weight: bold;
  font-size: 16px !important;
  border: none;
  background-color: #f0f0f0;
}

table {
  border-collapse: collapse;
  table-layout: fixed;
}

table, th, td {
  border: 2px solid black;
  width: 50px;
  height: 50px;
  text-align: center;
  vertical-align: middle;
  overflow: hidden;
  box-sizing: border-box;
  font-size: 30px;
}

td.ch_black {
  background-color: #c2c2c2;
}

.black-piece {
    -webkit-text-stroke: 1px white;
    text-stroke: 1px white;
}
</style>

<head>
<title>Chess Game</title>
</head>
<body>

<h1>Game of chess</h1>

<table class="coordinate-wrapper">
			<tr>
				<td class="rank-coord">8</td>
				<td id="a8" ></td>
				<td id="b8" class="ch_black"></td>
				<td id="c8"></td>
				<td id="d8" class="ch_black"></td>
				<td id="e8"></td>
				<td id="f8" class="ch_black"></td>
				<td id="g8"></td>
				<td id="h8" class="ch_black"></td>
			</tr>
		  <tr>
			<td class="rank-coord">7</td>
			<td id="a7" class="ch_black"></td>
			<td id="b7"> </td>
			<td id="c7" class="ch_black"></td>
			<td id="d7" ></td>
			<td id="e7" class="ch_black"></td>
			<td id="f7"></td>
			<td id="g7" class="ch_black"></td>
			<td id="h7"></td>
		  </tr>
		  <tr>
			<td class="rank-coord">6</td>
			<td id="a6" ></td>
			<td id="b6" class="ch_black"></td>
			<td id="c6"></td>
			<td id="d6" class="ch_black"></td>
			<td id="e6"></td>
			<td id="f6" class="ch_black"></td>
			<td id="g6"></td>
			<td id="h6" class="ch_black"></td>
		  </tr>
		  <tr>
			<td class="rank-coord">5</td>
			<td id="a5" class="ch_black"></td>
			<td id="b5"> </td>
			<td id="c5" class="ch_black"></td>
			<td id="d5" ></td>
			<td id="e5" class="ch_black"></td>
			<td id="f5"></td>
			<td id="g5" class="ch_black"></td>
			<td id="h5"></td>
		  </tr>
		  <tr>
			<td class="rank-coord">4</td>
			<td id="a4" ></td>
			<td id="b4" class="ch_black"></td>
			<td id="c4"></td>
			<td id="d4" class="ch_black"></td>
			<td id="e4"></td>
			<td id="f4" class="ch_black"></td>
			<td id="g4"></td>
			<td id="h4" class="ch_black"></td>
		  </tr>
		  <tr>
			<td class="rank-coord">3</td>
			<td id="a3" class="ch_black"></td>
			<td id="b3"> </td>
			<td id="c3" class="ch_black"></td>
			<td id="d3" ></td>
			<td id="e3" class="ch_black"></td>
			<td id="f3"></td>
			<td id="g3" class="ch_black"></td>
			<td id="h3"></td>
		  </tr>
		  <tr>
			<td class="rank-coord">2</td>
			<td id="a2" ></td>
			<td id="b2" class="ch_black"></td>
			<td id="c2"></td>
			<td id="d2" class="ch_black"></td>
			<td id="e2"></td>
			<td id="f2" class="ch_black"></td>
			<td id="g2"></td>
			<td id="h2" class="ch_black"></td>
		  </tr>
		  <tr>
			<td class="rank-coord">1</td>
			<td id="a1" class="ch_black"></td>
			<td id="b1"> </td>
			<td id="c1" class="ch_black"></td>
			<td id="d1" ></td>
			<td id="e1" class="ch_black"></td>
			<td id="f1"></td>
			<td id="g1" class="ch_black"></td>
			<td id="h1"></td>
		  </tr>
		  <tr>
    <td class="file-coord"></td>
	<td class="file-coord">a</td>
    <td class="file-coord">b</td>
    <td class="file-coord">c</td>
    <td class="file-coord">d</td>
    <td class="file-coord">e</td>
    <td class="file-coord">f</td>
    <td class="file-coord">g</td>
    <td class="file-coord">h</td>
  </tr>
 </table>
		

<script>
const pieces = [
    { name: 'pawn', color: 'white', score: 1, location: 'a2', symbol: '♙', id: 'w-pawn-a' },
	{ name: 'pawn', color: 'white', score: 1, location: 'b2', symbol: '♙', id: 'w-pawn-b' },
	{ name: 'pawn', color: 'white', score: 1, location: 'c2', symbol: '♙', id: 'w-pawn-c' },
	{ name: 'pawn', color: 'white', score: 1, location: 'd2', symbol: '♙', id: 'w-pawn-d' },
	{ name: 'pawn', color: 'white', score: 1, location: 'e2', symbol: '♙', id: 'w-pawn-e' },
	{ name: 'pawn', color: 'white', score: 1, location: 'f2', symbol: '♙', id: 'w-pawn-f' },
	{ name: 'pawn', color: 'white', score: 1, location: 'g2', symbol: '♙', id: 'w-pawn-g' },
	{ name: 'pawn', color: 'white', score: 1, location: 'h2', symbol: '♙', id: 'w-pawn-h' },
	{ name: 'rook', color: 'white', score: 5, location: 'h1', symbol: '♖', id: 'w-K-rook' },
	{ name: 'rook', color: 'white', score: 5, location: 'a1', symbol: '♖', id: 'w-Q-rook' },
	{ name: 'knight', color: 'white', score: 3, location: 'g1', symbol: '♘', id: 'w-K-knight' },
	{ name: 'knight', color: 'white', score: 3, location: 'b1', symbol: '♘', id: 'w-Q-knight' },
	{ name: 'bishop', color: 'white', score: 3, location: 'f1', symbol: '♗', id: 'w-K-bishop' },
	{ name: 'bishop', color: 'white', score: 3, location: 'c1', symbol: '♗', id: 'w-Q-bishop' },
	{ name: 'queen', color: 'white', score: 8, location: 'd1', symbol: '♕', id: 'w-queen' },
	{ name: 'king', color: 'white', score: 0, location: 'e1', symbol: '♔', id: 'w-king' },
	
	{ name: 'pawn', color: 'black', score: 1, location: 'a7', symbol: '♟', id: 'b-pawn-a' },
	{ name: 'pawn', color: 'black', score: 1, location: 'b7', symbol: '♟', id: 'b-pawn-b' },
	{ name: 'pawn', color: 'black', score: 1, location: 'c7', symbol: '♟', id: 'b-pawn-c' },
	{ name: 'pawn', color: 'black', score: 1, location: 'd7', symbol: '♟', id: 'b-pawn-d' },
	{ name: 'pawn', color: 'black', score: 1, location: 'e7', symbol: '♟', id: 'b-pawn-e' },
	{ name: 'pawn', color: 'black', score: 1, location: 'f7', symbol: '♟', id: 'b-pawn-f' },
	{ name: 'pawn', color: 'black', score: 1, location: 'g7', symbol: '♟', id: 'b-pawn-g' },
	{ name: 'pawn', color: 'black', score: 1, location: 'h7', symbol: '♟', id: 'b-pawn-h' },
	{ name: 'rook', color: 'black', score: 5, location: 'h8', symbol: '♜', id: 'b-K-rook' },
	{ name: 'rook', color: 'black', score: 5, location: 'a8', symbol: '♜', id: 'b-Q-rook' },
	{ name: 'knight', color: 'black', score: 3, location: 'g8', symbol: '♞', id: 'b-K-knight' },
	{ name: 'knight', color: 'black', score: 3, location: 'b8', symbol: '♞', id: 'b-Q-knight' },
	{ name: 'bishop', color: 'black', score: 3, location: 'f8', symbol: '♝', id: 'b-K-bishop' },
	{ name: 'bishop', color: 'black', score: 3, location: 'c8', symbol: '♝', id: 'b-Q-bishop' },
	{ name: 'queen', color: 'black', score: 8, location: 'd8', symbol: '♛', id: 'b-queen' },
	{ name: 'king', color: 'black', score: 0, location: 'e8', symbol: '♚', id: 'b-king' }
];

//Names are self explanatory
let contestedPieces = [];
let contestedSquares = [];

let squaresClickable = false;
let selectedPiece = null;

//This used for Quenn and King side castling check
let Qw_piecesHaveMoved = [];
let Kw_piecesHaveMoved = [];

let Qb_piecesHaveMoved = [];
let Kb_piecesHaveMoved = [];



//This function handles the display of pieces, it's used to refresh the display after a move is done
function displayPieces() {
	
//this few lines clean the display, so if a move is made the piece won't duplicate
    const allCells = document.querySelectorAll('td[id]');//Is clears only td with ids, if you remove this, it will clear every cell including the coords
    allCells.forEach(cell => {
        cell.innerHTML = '';
    });
	
//This gets pieces(each and every one) object location and puts the piece there.	
    pieces.forEach(piece => {
        const cell = document.getElementById(piece.location);
        if (cell) {
            cell.innerHTML = piece.symbol;
        }
    });
}

//Checks all the available moves
function checkMoves() {
	pieces.forEach(piece =>{
	
		const currentFile = piece.location[0];
		const currentRank = parseInt(piece.location[1]);
	
		if(piece.name == "pawn"){
		
			//WHITE PAWN MOVES
			if(piece.color === 'white') {
				// Check diagonal captures
					const leftCapture = String.fromCharCode(currentFile.charCodeAt(0) + 1) + (currentRank + 1); 
					const rightCapture = String.fromCharCode(currentFile.charCodeAt(0) - 1) + (currentRank + 1); 
    
					[leftCapture, rightCapture].forEach(square => {
					
							contestedSquares.push({
								name: piece.id,
								contestedSquare: square
							});
					});
        
				} 
				//BLACK PAWN MOVES
				else {					
					// Check diagonal captures
					const leftCapture = String.fromCharCode(currentFile.charCodeAt(0) - 1) + (currentRank - 1); 
					const rightCapture = String.fromCharCode(currentFile.charCodeAt(0) + 1) + (currentRank - 1); 
    
					[leftCapture, rightCapture].forEach(square => {
					
							contestedSquares.push({
								name: piece.id,
								contestedSquare: square
							});
					});
				}
		}
		
		if(piece.name === 'knight') {
				
				let availableMoves = [];
				
				availableMoves.push(String.fromCharCode(currentFile.charCodeAt(0) + 2) + (currentRank + 1));
				availableMoves.push(String.fromCharCode(currentFile.charCodeAt(0) - 2) + (currentRank + 1));
				availableMoves.push(String.fromCharCode(currentFile.charCodeAt(0) + 1) + (currentRank + 2));
				availableMoves.push(String.fromCharCode(currentFile.charCodeAt(0) - 1) + (currentRank + 2));
				availableMoves.push(String.fromCharCode(currentFile.charCodeAt(0) + 2) + (currentRank - 1));
				availableMoves.push(String.fromCharCode(currentFile.charCodeAt(0) - 2) + (currentRank - 1));
				availableMoves.push(String.fromCharCode(currentFile.charCodeAt(0) + 1) + (currentRank - 2));
				availableMoves.push(String.fromCharCode(currentFile.charCodeAt(0) - 1) + (currentRank - 2));
				
				
				availableMoves.forEach(move => { 
				const pieceOnSquare = pieces.find(p => p.location === move);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== piece.color){
							const cell = document.getElementById(move);
							if(cell){
								contestedPieces.push({
									name: pieceOnSquare.id,
									contestedPieceLoc: move
								});
							}
						}
					}
					else{
						const cell = document.getElementById(move);
						if(cell) {
							contestedSquares.push({
								name: piece.id,
								contestedSquare: move
							});
						}
					}
				});
			}
			
		if(piece.name === 'bishop'){
				
				let rightDiagonalUp = [];
				let leftDiagonalUp = [];
				let leftDiagonalDown = [];
				let rightDiagonalDown = [];
								
				for(let i=1; i<9; i++){
					rightDiagonalUp.push(String.fromCharCode(currentFile.charCodeAt(0) + i) + (currentRank + i));
					const pieceOnSquare = pieces.find(p => p.location === rightDiagonalUp[i-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== piece.color){
							const cell = document.getElementById(rightDiagonalUp[i-1]);
								if(cell){
									contestedPieces.push({
										name: pieceOnSquare.id,
										contestedPieceLoc: rightDiagonalUp[i-1]
									});
								}
								
						}
						break;
					}
						else{
							const cell = document.getElementById(rightDiagonalUp[i-1]);
								if(cell) {
									contestedSquares.push({
										name: piece.id,
										contestedSquare: rightDiagonalUp[i-1]
									});
								}
						}									
				}
				
				for(let j=1; j<9; j++){
					leftDiagonalUp.push(String.fromCharCode(currentFile.charCodeAt(0) - j) + (currentRank + j));
					const pieceOnSquare = pieces.find(p => p.location === leftDiagonalUp[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== piece.color){
							const cell = document.getElementById(leftDiagonalUp[j-1]);
								if(cell){
									contestedPieces.push({
										name: pieceOnSquare.id,
										contestedPieceLoc: leftDiagonalUp[j-1]
									});
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(leftDiagonalUp[j-1]);
							if(cell) {
								contestedSquares.push({
									name: piece.id,
									contestedSquare: leftDiagonalUp[j-1]
								});
							}
					}					
				}
				
				for(let j=1; j<9; j++){
					leftDiagonalDown.push(String.fromCharCode(currentFile.charCodeAt(0) - j) + (currentRank - j));
					const pieceOnSquare = pieces.find(p => p.location === leftDiagonalDown[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== piece.color){
							const cell = document.getElementById(leftDiagonalDown[j-1]);
								if(cell){
									contestedPieces.push({
										name: pieceOnSquare.id,
										contestedPieceLoc: leftDiagonalDown[j-1]
									});
								}								
						}
						break;
					}
					else{
						const cell = document.getElementById(leftDiagonalDown[j-1]);
							if(cell) {
								contestedSquares.push({
									name: piece.id,
									contestedSquare: leftDiagonalDown[j-1]
								});
							}
					}					
				}
				
				for(let j=1; j<9; j++){
					rightDiagonalDown.push(String.fromCharCode(currentFile.charCodeAt(0) + j) + (currentRank - j));
					const pieceOnSquare = pieces.find(p => p.location === rightDiagonalDown[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== piece.color){
							const cell = document.getElementById(rightDiagonalDown[j-1]);
								if(cell){
									contestedPieces.push({
										name: pieceOnSquare.id,
										contestedPieceLoc: rightDiagonalDown[j-1]
									});
								}							
						}
						break;
					}
					else{
						const cell = document.getElementById(rightDiagonalDown[j-1]);
							if(cell) {
								contestedSquares.push({
									name: piece.id,
									contestedSquare: rightDiagonalDown[j-1]
								});
							}
					}
					
				}				
			}	
	
		if(piece.name === 'rook'){
				
				let = upLine = [];
				let = downLine = [];
				let = leftLine = [];
				let = rightLine = [];
				
				for(let j=1; j<9; j++){
					upLine.push(currentFile + (currentRank + j));
					const pieceOnSquare = pieces.find(p => p.location === upLine[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== piece.color){
							const cell = document.getElementById(upLine[j-1]);
								if(cell){
									contestedPieces.push({
										name: pieceOnSquare.id,
										contestedPieceLoc: upLine[j-1]
									});
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(upLine[j-1]);
							if(cell) {
								contestedSquares.push({
										name: piece.id,
										contestedSquare: upLine[j-1]
									});
							}
					}
					
				}
				
				for(let j=1; j<9; j++){
					downLine.push(currentFile + (currentRank - j));
					const pieceOnSquare = pieces.find(p => p.location === downLine[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== piece.color){
							const cell = document.getElementById(downLine[j-1]);
								if(cell){
									contestedPieces.push({
										name: pieceOnSquare.id,
										contestedPieceLoc: downLine[j-1]
									});
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(downLine[j-1]);
							if(cell) {
								contestedSquares.push({
									name: piece.id,
									contestedSquare: downLine[j-1]
								});
							}
					}
					
				}
				
				for(let j=1; j<9; j++){
					leftLine.push(String.fromCharCode(currentFile.charCodeAt(0) - j) + currentRank);
					const pieceOnSquare = pieces.find(p => p.location === leftLine[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== piece.color){
							const cell = document.getElementById(leftLine[j-1]);
								if(cell){
									contestedPieces.push({
										name: pieceOnSquare.id,
										contestedPieceLoc: leftLine[j-1]
									});
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(leftLine[j-1]);
							if(cell) {
								contestedSquares.push({
									name: piece.id,
									contestedSquare: leftLine[j-1]
								});
							}
					}
					
				}
				
				for(let j=1; j<9; j++){
					rightLine.push(String.fromCharCode(currentFile.charCodeAt(0) + j) + currentRank);
					const pieceOnSquare = pieces.find(p => p.location === rightLine[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== piece.color){
							const cell = document.getElementById(rightLine[j-1]);
								if(cell){
									contestedPieces.push({
										name: pieceOnSquare.id,
										contestedPieceLoc: rightLine[j-1]
									});
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(rightLine[j-1]);
							if(cell) {
								contestedSquares.push({
									name: piece.id,
									contestedSquare: rightLine[j-1]
								});
							}
					}
					
				}
				
			}
	});
	
	//console.log(contestedSquares);
}

//Listens for a click on the cell, when a click happens, it sends the clicked cell id to function
function selectSquare() {
    const allCells = document.querySelectorAll('td');
    allCells.forEach(cell => {
        cell.addEventListener('click', function() {
            handleSquareClick(cell.id);
        });
    });
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//THIS HANDLES HOW THE PIECES MOVE/ATTACK
function handleSquareClick(cellId) {
	// Check all cells
	const allCells = document.querySelectorAll('td');
	
    // Check if there's a piece on this square
    const pieceOnSquare = pieces.find(p => p.location === cellId);
		
	if(!pieceOnSquare && !selectedPiece) {
		console.log('Empty cell!')
	}
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//THIS SHOWS THE AVAILABLE MOVES FOR A PIECE 
    else if (pieceOnSquare && !selectedPiece) {
        // Select the piece if no piece is currently selected
        selectedPiece = pieceOnSquare;
        console.log('Selected:', selectedPiece.name, 'at', selectedPiece.location);
        squaresClickable = true;
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		const currentFile = selectedPiece.location[0];
		const currentRank = parseInt(selectedPiece.location[1]);
		//THIS GOES FOR PAWN
			if(selectedPiece.name === 'pawn') {
    
				let validSquares = [];
				let captureSquares = [];
				//WHITE PAWN MOVES
				if(selectedPiece.color === 'white') {
					// White pawns move "up" (rank numbers are being added up)
					
					// Check one square forward
					const oneForward = currentFile + (currentRank + 1);
					const pieceOneForward = pieces.find(p => p.location === oneForward);
					
					if(!pieceOneForward) {  // No piece blocking
						validSquares.push(oneForward);
					
						 // Check two squares forward (only if one square is clear)
						if(currentRank === 2) {
						const twoForward = currentFile + (currentRank + 2);
						const pieceTwoForward = pieces.find(p => p.location === twoForward);
							if(!pieceTwoForward) {
								validSquares.push(twoForward);
							}
						}
					} 
				
				 // Check diagonal captures
					const leftCapture = String.fromCharCode(currentFile.charCodeAt(0) - 1) + (currentRank + 1);
					const rightCapture = String.fromCharCode(currentFile.charCodeAt(0) + 1) + (currentRank + 1);
        
					[leftCapture, rightCapture].forEach(square => {
					const pieceOnSquare = pieces.find(p => p.location === square);
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color) {
							captureSquares.push(square);
						}
					});
        
				} 
				//BLACK PAWN MOVES
				else {
					const oneForward = currentFile + (currentRank - 1);
					const pieceOneForward = pieces.find(p => p.location === oneForward);
					
					if(!pieceOneForward) {  // No piece blocking
						validSquares.push(oneForward);
					
						 // Check two squares forward (only if one square is clear)
						if(currentRank === 7) {
						const twoForward = currentFile + (currentRank - 2);
						const pieceTwoForward = pieces.find(p => p.location === twoForward);
							if(!pieceTwoForward) {
								validSquares.push(twoForward);
							}
						}
					} 
					
					// Check diagonal captures
					const leftCapture = String.fromCharCode(currentFile.charCodeAt(0) - 1) + (currentRank - 1);
					const rightCapture = String.fromCharCode(currentFile.charCodeAt(0) + 1) + (currentRank - 1);
        
					[leftCapture, rightCapture].forEach(square => {
					const pieceOnSquare = pieces.find(p => p.location === square);
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color) {
							captureSquares.push(square);
						}
					});
				}
				
				// Mark valid move squares
				validSquares.forEach(squareId => {
				const cell = document.getElementById(squareId);
					if(cell) {
						cell.innerHTML = '●';  // Normal moves
					}
				});
    
				// Mark capture squares
				captureSquares.forEach(squareId => {
				const cell = document.getElementById(squareId);
					if(cell) {
						cell.innerHTML += '○';  // Captures
					}
				});
			}
			
			if(selectedPiece.name === 'knight') {
				
				let availableMoves = [];
				
				availableMoves.push(String.fromCharCode(currentFile.charCodeAt(0) + 2) + (currentRank + 1));
				availableMoves.push(String.fromCharCode(currentFile.charCodeAt(0) - 2) + (currentRank + 1));
				availableMoves.push(String.fromCharCode(currentFile.charCodeAt(0) + 1) + (currentRank + 2));
				availableMoves.push(String.fromCharCode(currentFile.charCodeAt(0) - 1) + (currentRank + 2));
				availableMoves.push(String.fromCharCode(currentFile.charCodeAt(0) + 2) + (currentRank - 1));
				availableMoves.push(String.fromCharCode(currentFile.charCodeAt(0) - 2) + (currentRank - 1));
				availableMoves.push(String.fromCharCode(currentFile.charCodeAt(0) + 1) + (currentRank - 2));
				availableMoves.push(String.fromCharCode(currentFile.charCodeAt(0) - 1) + (currentRank - 2));
				
				
				availableMoves.forEach(move => { 
				const pieceOnSquare = pieces.find(p => p.location === move);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(move);
							if(cell){
								cell.innerHTML += '○';
							}
						}
					}
					else{
						const cell = document.getElementById(move);
						if(cell) {
							cell.innerHTML = '●';  // Normal moves
						}
					}
				});
			
			}
			
			if(selectedPiece.name === 'bishop'){
				
				let rightDiagonalUp = [];
				let leftDiagonalUp = [];
				let leftDiagonalDown = [];
				let rightDiagonalDown = [];
								
				for(let i=1; i<9; i++){
					rightDiagonalUp.push(String.fromCharCode(currentFile.charCodeAt(0) + i) + (currentRank + i));
					const pieceOnSquare = pieces.find(p => p.location === rightDiagonalUp[i-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(rightDiagonalUp[i-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
						else{
							const cell = document.getElementById(rightDiagonalUp[i-1]);
								if(cell) {
									cell.innerHTML = '●';  // Normal moves
								}
						}
					
					
				}
				
				for(let j=1; j<9; j++){
					leftDiagonalUp.push(String.fromCharCode(currentFile.charCodeAt(0) - j) + (currentRank + j));
					const pieceOnSquare = pieces.find(p => p.location === leftDiagonalUp[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(leftDiagonalUp[j-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(leftDiagonalUp[j-1]);
							if(cell) {
								cell.innerHTML = '●';  // Normal moves
							}
					}
					
				}
				
				for(let j=1; j<9; j++){
					leftDiagonalDown.push(String.fromCharCode(currentFile.charCodeAt(0) - j) + (currentRank - j));
					const pieceOnSquare = pieces.find(p => p.location === leftDiagonalDown[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(leftDiagonalDown[j-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(leftDiagonalDown[j-1]);
							if(cell) {
								cell.innerHTML = '●';  // Normal moves
							}
					}
					
				}
				
				for(let j=1; j<9; j++){
					rightDiagonalDown.push(String.fromCharCode(currentFile.charCodeAt(0) + j) + (currentRank - j));
					const pieceOnSquare = pieces.find(p => p.location === rightDiagonalDown[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(rightDiagonalDown[j-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(rightDiagonalDown[j-1]);
							if(cell) {
								cell.innerHTML = '●';  // Normal moves
							}
					}
					
				}
				
			}
			
			if(selectedPiece.name === 'rook'){
				
				let = upLine = [];
				let = downLine = [];
				let = leftLine = [];
				let = rightLine = [];
				
				for(let j=1; j<9; j++){
					upLine.push(currentFile + (currentRank + j));
					const pieceOnSquare = pieces.find(p => p.location === upLine[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(upLine[j-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(upLine[j-1]);
							if(cell) {
								cell.innerHTML = '●';  // Normal moves
							}
					}
					
				}
				
				for(let j=1; j<9; j++){
					downLine.push(currentFile + (currentRank - j));
					const pieceOnSquare = pieces.find(p => p.location === downLine[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(downLine[j-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(downLine[j-1]);
							if(cell) {
								cell.innerHTML = '●';  // Normal moves
							}
					}
					
				}
				
				for(let j=1; j<9; j++){
					leftLine.push(String.fromCharCode(currentFile.charCodeAt(0) - j) + currentRank);
					const pieceOnSquare = pieces.find(p => p.location === leftLine[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(leftLine[j-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(leftLine[j-1]);
							if(cell) {
								cell.innerHTML = '●';  // Normal moves
							}
					}
					
				}
				
				for(let j=1; j<9; j++){
					rightLine.push(String.fromCharCode(currentFile.charCodeAt(0) + j) + currentRank);
					const pieceOnSquare = pieces.find(p => p.location === rightLine[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(rightLine[j-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(rightLine[j-1]);
							if(cell) {
								cell.innerHTML = '●';  // Normal moves
							}
					}
					
				}
				
			}
			
			if(selectedPiece.name === 'queen'){
				let upLine = [];
				let downLine = [];
				let leftLine = [];
				let rightLine = [];
				let leftDiagonalUp = [];
				let rightDiagonalUp = [];
				let rightDiagonalDown = [];
				let leftDiagonalDown = [];
				
				for(let j=1; j<9; j++){
					upLine.push(currentFile + (currentRank + j));
					const pieceOnSquare = pieces.find(p => p.location === upLine[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(upLine[j-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(upLine[j-1]);
							if(cell) {
								cell.innerHTML = '●';  // Normal moves
							}
					}
					
				}
				
				for(let j=1; j<9; j++){
					downLine.push(currentFile + (currentRank - j));
					const pieceOnSquare = pieces.find(p => p.location === downLine[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(downLine[j-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(downLine[j-1]);
							if(cell) {
								cell.innerHTML = '●';  // Normal moves
							}
					}
					
				}
				
				for(let j=1; j<9; j++){
					leftLine.push(String.fromCharCode(currentFile.charCodeAt(0) - j) + currentRank);
					const pieceOnSquare = pieces.find(p => p.location === leftLine[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(leftLine[j-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(leftLine[j-1]);
							if(cell) {
								cell.innerHTML = '●';  // Normal moves
							}
					}
					
				}
				
				for(let j=1; j<9; j++){
					rightLine.push(String.fromCharCode(currentFile.charCodeAt(0) + j) + currentRank);
					const pieceOnSquare = pieces.find(p => p.location === rightLine[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(rightLine[j-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(rightLine[j-1]);
							if(cell) {
								cell.innerHTML = '●';  // Normal moves
							}
					}
					
				}
				
				for(let i=1; i<9; i++){
					rightDiagonalUp.push(String.fromCharCode(currentFile.charCodeAt(0) + i) + (currentRank + i));
					const pieceOnSquare = pieces.find(p => p.location === rightDiagonalUp[i-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(rightDiagonalUp[i-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
						else{
							const cell = document.getElementById(rightDiagonalUp[i-1]);
								if(cell) {
									cell.innerHTML = '●';  // Normal moves
								}
						}
					
					
				}
				
				for(let j=1; j<9; j++){
					leftDiagonalUp.push(String.fromCharCode(currentFile.charCodeAt(0) - j) + (currentRank + j));
					const pieceOnSquare = pieces.find(p => p.location === leftDiagonalUp[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(leftDiagonalUp[j-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(leftDiagonalUp[j-1]);
							if(cell) {
								cell.innerHTML = '●';  // Normal moves
							}
					}
					
				}
				
				for(let j=1; j<9; j++){
					leftDiagonalDown.push(String.fromCharCode(currentFile.charCodeAt(0) - j) + (currentRank - j));
					const pieceOnSquare = pieces.find(p => p.location === leftDiagonalDown[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(leftDiagonalDown[j-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(leftDiagonalDown[j-1]);
							if(cell) {
								cell.innerHTML = '●';  // Normal moves
							}
					}
					
				}
				
				for(let j=1; j<9; j++){
					rightDiagonalDown.push(String.fromCharCode(currentFile.charCodeAt(0) + j) + (currentRank - j));
					const pieceOnSquare = pieces.find(p => p.location === rightDiagonalDown[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(rightDiagonalDown[j-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(rightDiagonalDown[j-1]);
							if(cell) {
								cell.innerHTML = '●';  // Normal moves
							}
					}
					
				}
			}
			
			if(selectedPiece.name == 'king'){
				let upLine = [];
				let downLine = [];
				let leftLine = [];
				let rightLine = [];
				let leftDiagonalUp = [];
				let rightDiagonalUp = [];
				let rightDiagonalDown = [];
				let leftDiagonalDown = [];
				
				for(let j=1; j<2; j++){
					upLine.push(currentFile + (currentRank + j));
					const pieceOnSquare = pieces.find(p => p.location === upLine[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(upLine[j-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(upLine[j-1]);
							if(cell) {
								cell.innerHTML = '●';  // Normal moves
							}
					}
					
				}
				
				for(let j=1; j<2; j++){
					downLine.push(currentFile + (currentRank - j));
					const pieceOnSquare = pieces.find(p => p.location === downLine[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(downLine[j-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(downLine[j-1]);
							if(cell) {
								cell.innerHTML = '●';  // Normal moves
							}
					}
					
				}
				
				for(let j=1; j<2; j++){
					leftLine.push(String.fromCharCode(currentFile.charCodeAt(0) - j) + currentRank);
					const pieceOnSquare = pieces.find(p => p.location === leftLine[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(leftLine[j-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(leftLine[j-1]);
							if(cell) {
								cell.innerHTML = '●';  // Normal moves
							}
					}
					
				}
				
				for(let j=1; j<2; j++){
					rightLine.push(String.fromCharCode(currentFile.charCodeAt(0) + j) + currentRank);
					const pieceOnSquare = pieces.find(p => p.location === rightLine[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(rightLine[j-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(rightLine[j-1]);
							if(cell) {
								cell.innerHTML = '●';  // Normal moves
							}
					}
					
				}
				
				for(let i=1; i<2; i++){
					rightDiagonalUp.push(String.fromCharCode(currentFile.charCodeAt(0) + i) + (currentRank + i));
					const pieceOnSquare = pieces.find(p => p.location === rightDiagonalUp[i-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(rightDiagonalUp[i-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
						else{
							const cell = document.getElementById(rightDiagonalUp[i-1]);
								if(cell) {
									cell.innerHTML = '●';  // Normal moves
								}
						}
					
					
				}
				
				for(let j=1; j<2; j++){
					leftDiagonalUp.push(String.fromCharCode(currentFile.charCodeAt(0) - j) + (currentRank + j));
					const pieceOnSquare = pieces.find(p => p.location === leftDiagonalUp[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(leftDiagonalUp[j-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(leftDiagonalUp[j-1]);
							if(cell) {
								cell.innerHTML = '●';  // Normal moves
							}
					}
					
				}
				
				for(let j=1; j<2; j++){
					leftDiagonalDown.push(String.fromCharCode(currentFile.charCodeAt(0) - j) + (currentRank - j));
					const pieceOnSquare = pieces.find(p => p.location === leftDiagonalDown[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(leftDiagonalDown[j-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(leftDiagonalDown[j-1]);
							if(cell) {
								cell.innerHTML = '●';  // Normal moves
							}
					}
					
				}
				
				for(let j=1; j<2; j++){
					rightDiagonalDown.push(String.fromCharCode(currentFile.charCodeAt(0) + j) + (currentRank - j));
					const pieceOnSquare = pieces.find(p => p.location === rightDiagonalDown[j-1]);
					if(pieceOnSquare){
						if(pieceOnSquare && pieceOnSquare.color !== selectedPiece.color){
							const cell = document.getElementById(rightDiagonalDown[j-1]);
								if(cell){
									cell.innerHTML += '○';
								}
								
						}
						break;
					}
					else{
						const cell = document.getElementById(rightDiagonalDown[j-1]);
							if(cell) {
								cell.innerHTML = '●';  // Normal moves
							}
					}
					
				}
			}
			
	} 
	
		
	//If a piece is selected and the square, where you want to put it already has a piece
	else if (pieceOnSquare && selectedPiece) {
		console.log('There is a piece here!');
		selectedPiece = null;
		squaresClickable = false;
		
		allCells.forEach(cell => {
			if(cell.innerHTML === '●' || cell.innerHTML.includes('○')){
					cell.innerHTML = cell.innerHTML.replace('●', '').replace('○', '');
			}
		});
	}
	
	else if (selectedPiece && squaresClickable) {
		allCells.forEach(cell => {
			if(cell.id == cellId){
				if(cell.innerHTML == '●' || cell.innerHTML == '○'){
					// Move the selected piece to this square
					moveToSquare(cellId);
				}	
				else{
					console.log('Can\'t move there, mate');
					selectedPiece = null;
					squaresClickable = false;
			
					allCells.forEach(cell => {
						if(cell.innerHTML === '●' || cell.innerHTML.includes('○')){
							 cell.innerHTML = cell.innerHTML.replace('●', '').replace('○', '');
						}
					});
				}
			}
		});
    } 
}

function isKingInCheck(kingColor) {
   // Find the king of the specified color
   const king = pieces.find(p => p.name === 'king' && p.color === kingColor);
   
   if (!king) {
       return false; // King not found
   }
   
   // Check if any contested piece is this king
   return contestedPieces.some(contest => contest.name === king.id);
}

// Function to check if a square is under attack by opponent
function isSquareContested(square, byColor) {
    return contestedSquares.some(contest => {
        const attackingPiece = pieces.find(p => p.id === contest.name);
        return contest.contestedSquare === square && 
               attackingPiece && 
               attackingPiece.color === byColor;
    });
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////AS OF NOW THIS FUNCTION HANDLES MOVE'S END, meaning when this function is complete the display is reset
/////ALSO CASTLING
function moveToSquare(cellId) { //cellId if id of a cell for piece to go
    if (selectedPiece && squaresClickable) {
        
		//This is used for checking contested squares and attacked pieces. Doing this before anything else to be safe
		contestedPieces.length = 0;
		contestedSquares.length = 0;
		checkMoves();
		
		const whiteRook = pieces.find(p => p.id === 'w-Q-rook');
				
		if(selectedPiece.name == 'king' && 
			cellId == 'd1' && //
			selectedPiece.location == 'e1' && 
			whiteRook.location == 'a1' && 
			isKingInCheck('white') == false && 
			Qw_piecesHaveMoved.length === 2 &&
			!isSquareContested('d1', 'black') &&
			!isSquareContested('c1', 'black')){
			
			selectedPiece.location = 'c1';
			whiteRook.location = 'd1';
		} 
		else if(selectedPiece.name == 'king' && isSquareContested(cellId, 'black') && selectedPiece.color == 'white'){
			console.log('That\'s a check!');
			
			return;
		}
		else{
			selectedPiece.location = cellId;
			//console.log(selectedPiece.name, isSquareContested(cellId, 'black' && selectedPiece.color == 'white');
		}
		
		//both ifs check is black and white queen side pieces have moved, to perform castling
		if(selectedPiece.id == 'w-Q-bishop' || selectedPiece.id == 'w-Q-knight'){
			Qw_piecesHaveMoved.push(selectedPiece.id);
			console.log(Qw_piecesHaveMoved.length);
		}
		if(selectedPiece.id == 'b-Q-bishop' || selectedPiece.id == 'b-Q-knight'){
			Qb_piecesHaveMoved.push(selectedPiece.id);
		}
		
		/////////////////////////////////////////////////////////////////////////////////////////////
		///This part is move's end phase, cleaning up the variables, refreshing display
        displayPieces(); // Refresh the board
        selectedPiece = null; // Deselect
		squaresClickable = false;
		
		//cleaning up again
		contestedPieces.length = 0;
		contestedSquares.length = 0;
		checkMoves();

		//QUEEN SIDE CASTLING	
		if(isKingInCheck('white')){
			console.log('Check!')
		}
    }
}

selectSquare();
displayPieces();

</script>

</body>
</html>


